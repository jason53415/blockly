// This file was automatically generated.  Do not modify.

'use strict';

Blockly.Msg["ADD_COMMENT"] = "주석 추가";
Blockly.Msg["CANNOT_DELETE_VARIABLE_PROCEDURE"] = "'%2' 함수 정의의 일부이기 때문에 '%1' 변수를 삭제할 수 없습니다";
Blockly.Msg["CHANGE_VALUE_TITLE"] = "값 바꾸기:";
Blockly.Msg["CLEAN_UP"] = "블록 정리";
Blockly.Msg["COLLAPSED_WARNINGS_WARNING"] = "접힌 블록이 경고를 포함하고 있습니다.";
Blockly.Msg["COLLAPSE_ALL"] = "블록 축소";
Blockly.Msg["COLLAPSE_BLOCK"] = "블록 축소";
Blockly.Msg["COLOUR_BLEND_COLOUR1"] = "색 1";
Blockly.Msg["COLOUR_BLEND_COLOUR2"] = "색 2";
Blockly.Msg["COLOUR_BLEND_HELPURL"] = "http://meyerweb.com/eric/tools/color-blend/";
Blockly.Msg["COLOUR_BLEND_RATIO"] = "비율";
Blockly.Msg["COLOUR_BLEND_TITLE"] = "혼합";
Blockly.Msg["COLOUR_BLEND_TOOLTIP"] = "두 색을 주어진 비율로 혼합 (0.0 - 1.0)";
Blockly.Msg["COLOUR_PICKER_HELPURL"] = "https://ko.wikipedia.org/wiki/색";
Blockly.Msg["COLOUR_PICKER_TOOLTIP"] = "팔레트에서 색을 고릅니다";
Blockly.Msg["COLOUR_RANDOM_HELPURL"] = "http://randomcolour.com";  // untranslated
Blockly.Msg["COLOUR_RANDOM_TITLE"] = "무작위 색상";
Blockly.Msg["COLOUR_RANDOM_TOOLTIP"] = "무작위로 색을 고릅니다.";
Blockly.Msg["COLOUR_RGB_BLUE"] = "파랑";
Blockly.Msg["COLOUR_RGB_GREEN"] = "초록";
Blockly.Msg["COLOUR_RGB_HELPURL"] = "http://www.december.com/html/spec/colorper.html";
Blockly.Msg["COLOUR_RGB_RED"] = "빨강";
Blockly.Msg["COLOUR_RGB_TITLE"] = "색";
Blockly.Msg["COLOUR_RGB_TOOLTIP"] = "빨강,파랑,초록의 값을 이용하여 색을 만드십시오. 모든 값은 0과 100 사이에 있어야 합니다.";
Blockly.Msg["CONTROLS_FLOW_STATEMENTS_HELPURL"] = "https://ko.wikipedia.org/wiki/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84";
Blockly.Msg["CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK"] = "반복 중단";
Blockly.Msg["CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE"] = "다음 반복";
Blockly.Msg["CONTROLS_FLOW_STATEMENTS_TOOLTIP_BREAK"] = "현재 반복 실행 블럭을 빠져나갑니다.";
Blockly.Msg["CONTROLS_FLOW_STATEMENTS_TOOLTIP_CONTINUE"] = "나머지 반복 부분을 더 이상 실행하지 않고, 다음 반복을 수행합니다.";
Blockly.Msg["CONTROLS_FLOW_STATEMENTS_WARNING"] = "경고 : 이 블록은 반복 실행 블럭 안에서만 사용됩니다.";
Blockly.Msg["CONTROLS_FOREACH_HELPURL"] = "https://ko.wikipedia.org/wiki/For_%EB%A3%A8%ED%94%84#.EC.9E.84.EC.9D.98.EC.9D.98_.EC.A7.91.ED.95.A9";
Blockly.Msg["CONTROLS_FOREACH_TITLE"] = "각 항목에 대해 %1 목록으로 %2";
Blockly.Msg["CONTROLS_FOREACH_TOOLTIP"] = "리스트 안에 들어있는 각 아이템들을, 순서대로 변수 '%1' 에 한 번씩 저장시키고, 그 때 마다 명령을 실행합니다.";
Blockly.Msg["CONTROLS_FOR_HELPURL"] = "https://ko.wikipedia.org/wiki/For_%EB%A3%A8%ED%94%84";
Blockly.Msg["CONTROLS_FOR_TITLE"] = "으로 계산 %1 %2에서 %4을 이용하여 %3로";
Blockly.Msg["CONTROLS_FOR_TOOLTIP"] = "변수 \"%1\"은 지정된 간격으로 시작 수에서 끝 수까지를 세어 지정된 블록을 수행해야 합니다.";
Blockly.Msg["CONTROLS_IF_ELSEIF_TOOLTIP"] = "\"만약\" 블럭에 조건 검사를 추가합니다.";
Blockly.Msg["CONTROLS_IF_ELSE_TOOLTIP"] = "\"만약\" 블럭의 마지막에, 모든 검사 결과가 거짓인 경우 실행할 부분을 추가합니다.";
Blockly.Msg["CONTROLS_IF_HELPURL"] = "https://ko.wikipedia.org/wiki/%EC%A1%B0%EA%B1%B4%EB%AC%B8";
Blockly.Msg["CONTROLS_IF_IF_TOOLTIP"] = "섹션을 추가, 제거하거나 순서를 변경하여 이 if 블럭을 재구성합니다.";
Blockly.Msg["CONTROLS_IF_MSG_ELSE"] = "아니라면";
Blockly.Msg["CONTROLS_IF_MSG_ELSEIF"] = "다른 경우";
Blockly.Msg["CONTROLS_IF_MSG_IF"] = "만약";
Blockly.Msg["CONTROLS_IF_TOOLTIP_1"] = "조건식의 계산 결과가 참이면, 명령을 실행합니다.";
Blockly.Msg["CONTROLS_IF_TOOLTIP_2"] = "조건식의 계산 결과가 참이면, 첫 번째 블럭의 명령을 실행하고, 그렇지 않으면 두 번째 블럭의 명령을 실행합니다.";
Blockly.Msg["CONTROLS_IF_TOOLTIP_3"] = "첫 번째 조건식의 계산 결과가 참이면, 첫 번째 블럭의 명령을 실행하고, 두 번째 조건식의 계산 결과가 참이면, 두 번째 블럭의 명령을 실행합니다.";
Blockly.Msg["CONTROLS_IF_TOOLTIP_4"] = "첫 번째 조건식의 계산 결과가 참이면, 첫 번째 블럭의 명령을 실행하고, 두 번째 조건식의 계산 결과가 참이면, 두 번째 블럭의 명령을 실행하고, ... , 어떤 조건식의 계산 결과도 참이 아니면, 마지막 블럭의 명령을 실행합니다.";
Blockly.Msg["CONTROLS_REPEAT_HELPURL"] = "https://ko.wikipedia.org/wiki/For_루프";
Blockly.Msg["CONTROLS_REPEAT_INPUT_DO"] = "하기";
Blockly.Msg["CONTROLS_REPEAT_TITLE"] = "%1회 반복";
Blockly.Msg["CONTROLS_REPEAT_TOOLTIP"] = "여러 번 반복해 명령들을 실행합니다.";
Blockly.Msg["CONTROLS_WHILEUNTIL_HELPURL"] = "https://ko.wikipedia.org/wiki/While_%EB%A3%A8%ED%94%84";
Blockly.Msg["CONTROLS_WHILEUNTIL_OPERATOR_UNTIL"] = "다음까지 반복";
Blockly.Msg["CONTROLS_WHILEUNTIL_OPERATOR_WHILE"] = "동안 반복";
Blockly.Msg["CONTROLS_WHILEUNTIL_TOOLTIP_UNTIL"] = "값이 거짓일 때, 몇 가지 선언을 합니다.";
Blockly.Msg["CONTROLS_WHILEUNTIL_TOOLTIP_WHILE"] = "값이 참일 때, 몇 가지 선언을 합니다.";
Blockly.Msg["DELETE_ALL_BLOCKS"] = "모든 블록 %1개를 삭제하겠습니까?";
Blockly.Msg["DELETE_BLOCK"] = "블록 삭제";
Blockly.Msg["DELETE_VARIABLE"] = "'%1' 변수를 삭제합니다";
Blockly.Msg["DELETE_VARIABLE_CONFIRMATION"] = "'%2' 변수에서 %1을(를) 삭제하시겠습니까?";
Blockly.Msg["DELETE_X_BLOCKS"] = "블록 %1개 삭제";
Blockly.Msg["DIALOG_CANCEL"] = "취소";
Blockly.Msg["DIALOG_OK"] = "확인";
Blockly.Msg["DICTS_CREATE_EMPTY_TITLE"] = "create empty dictionary";  // untranslated
Blockly.Msg["DICTS_CREATE_WITH_CONTAINER_TITLE_ADD"] = "dictionary";  // untranslated
Blockly.Msg["DICTS_CREATE_WITH_CONTAINER_TOOLTIP"] = "Add, remove, or reorder sections to reconfigure this dictionary block.";  // untranslated
Blockly.Msg["DICTS_CREATE_WITH_INPUT_WITH"] = "create dictionary with";  // untranslated
Blockly.Msg["DICTS_CREATE_WITH_ITEM_KEY"] = "key";  // untranslated
Blockly.Msg["DICTS_CREATE_WITH_ITEM_TITLE"] = "key-value";  // untranslated
Blockly.Msg["DICTS_CREATE_WITH_ITEM_TOOLTIP"] = "Make a new key-value pair.";  // untranslated
Blockly.Msg["DICTS_CREATE_WITH_ITEM_VALUE"] = "value";  // untranslated
Blockly.Msg["DICTS_CREATE_WITH_TOOLTIP"] = "Create a dictionary with any number of key-value pairs.";  // untranslated
Blockly.Msg["DICTS_GET_KEYS"] = "get all keys of %1";  // untranslated
Blockly.Msg["DICTS_GET_KEYS_TOOLTIP"] = "Get all keys of a dictionary.";  // untranslated
Blockly.Msg["DICTS_GET_VALUE"] = "in dictionary %1 get value of key %2";  // untranslated
Blockly.Msg["DICTS_GET_VALUE_TOOLTIP"] = "Retern the value of the specified key in a dictionary.";  // untranslated
Blockly.Msg["DICTS_SET_VALUE"] = "in dictionary %1 set value of key %2 as %3";  // untranslated
Blockly.Msg["DICTS_SET_VALUE_TOOLTIP"] = "Set the value of the specified key in a dictionary.";  // untranslated
Blockly.Msg["DISABLE_BLOCK"] = "블록 비활성화";
Blockly.Msg["DUPLICATE_BLOCK"] = "복제";
Blockly.Msg["DUPLICATE_COMMENT"] = "주석 복제하기";
Blockly.Msg["ENABLE_BLOCK"] = "블록 활성화";
Blockly.Msg["EXPAND_ALL"] = "블록 확장";
Blockly.Msg["EXPAND_BLOCK"] = "블록 확장";
Blockly.Msg["EXTERNAL_INPUTS"] = "외부 입력";
Blockly.Msg["FILE_CSV_LOAD"] = "load a two-dimensional list %1 from %2.csv using delimiter %3";  // untranslated
Blockly.Msg["FILE_CSV_LOAD_TOOLTIP"] = "Load a two-dimensional list from a CSV file using a specific delimiter.";  // untranslated
Blockly.Msg["FILE_CSV_SAVE"] = "save a two-dimensional list %1 as %2.csv using delimiter %3";  // untranslated
Blockly.Msg["FILE_CSV_SAVE_TOOLTIP"] = "save a two-dimensional list as a CSV file using a specific delimiter.";  // untranslated
Blockly.Msg["FILE_DEFAULT_NAME"] = "file_name";  // untranslated
Blockly.Msg["FILE_LOAD"] = "load %1 from %2.pickle";  // untranslated
Blockly.Msg["FILE_LOAD_TOOLTIP"] = "Load an object from a file.";  // untranslated
Blockly.Msg["FILE_SAVE"] = "save %1 as %2.pickle";  // untranslated
Blockly.Msg["FILE_SAVE_TOOLTIP"] = "Save an object as a file.";  // untranslated
Blockly.Msg["HELP"] = "도움말";
Blockly.Msg["INLINE_INPUTS"] = "내부 입력";
Blockly.Msg["LISTS_CREATE_EMPTY_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#create-empty-list";
Blockly.Msg["LISTS_CREATE_EMPTY_TITLE"] = "빈 리스트 생성";
Blockly.Msg["LISTS_CREATE_EMPTY_TOOLTIP"] = "데이터 레코드가 없는, 길이가 0인 목록을 반환합니다.";
Blockly.Msg["LISTS_CREATE_WITH_CONTAINER_TITLE_ADD"] = "리스트";
Blockly.Msg["LISTS_CREATE_WITH_CONTAINER_TOOLTIP"] = "섹션을 추가, 제거하거나 순서를 변경하여 이 리스트 블럭을 재구성합니다.";
Blockly.Msg["LISTS_CREATE_WITH_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#create-list-with";
Blockly.Msg["LISTS_CREATE_WITH_INPUT_WITH"] = "리스트 만들기";
Blockly.Msg["LISTS_CREATE_WITH_ITEM_TOOLTIP"] = "아이템을 리스트에 추가합니다.";
Blockly.Msg["LISTS_CREATE_WITH_TOOLTIP"] = "원하는 수의 항목들로 목록을 생성합니다.";
Blockly.Msg["LISTS_EXTEND_TITLE"] = "extend %1 with all elements in %2";  // untranslated
Blockly.Msg["LISTS_EXTEND_TOOLTIP"] = "Add all the elements in list 2 to the end of the list.";  // untranslated
Blockly.Msg["LISTS_EXTEND_VARIABLE"] = "list";  // untranslated
Blockly.Msg["LISTS_GET_INDEX_FIRST"] = "첫 번째";
Blockly.Msg["LISTS_GET_INDEX_FROM_END"] = "마지막 번째 위치부터, # 번째";
Blockly.Msg["LISTS_GET_INDEX_FROM_START"] = "#";
Blockly.Msg["LISTS_GET_INDEX_GET"] = "가져오기";
Blockly.Msg["LISTS_GET_INDEX_GET_REMOVE"] = "잘라 내기";
Blockly.Msg["LISTS_GET_INDEX_LAST"] = "마지막";
Blockly.Msg["LISTS_GET_INDEX_RANDOM"] = "임의로";
Blockly.Msg["LISTS_GET_INDEX_REMOVE"] = "삭제";
Blockly.Msg["LISTS_GET_INDEX_TAIL"] = "";
Blockly.Msg["LISTS_GET_INDEX_TITLE"] = "in list %1 %2 %3";  // untranslated
Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_GET_FIRST"] = "첫 번째 아이템을 찾아 돌려줍니다.";
Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_GET_FROM"] = "목록에서 특정 위치의 항목을 반환합니다.";
Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_GET_LAST"] = "마지막 아이템을 찾아 돌려줍니다.";
Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_GET_RANDOM"] = "리스트의 아이템들 중, 랜덤으로 선택해 돌려줍니다.";
Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FIRST"] = "첫 번째 아이템을 찾아내 돌려주고, 그 아이템을 리스트에서 삭제합니다.";
Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FROM"] = "목록의 특정 위치에 있는 항목을 제거하고 반환합니다.";
Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_LAST"] = "마지막 아이템을 찾아내 돌려주고, 그 아이템을 리스트에서 삭제합니다.";
Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_RANDOM"] = "목록에서 임의 위치의 아이템을 찾아내 삭제하고 돌려줍니다.";
Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_REMOVE_FIRST"] = "리스트에서 첫 번째 아이템을 삭제합니다.";
Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_REMOVE_FROM"] = "목록에서 특정 위치의 항목을 삭제합니다.";
Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_REMOVE_LAST"] = "리스트에서 마지막 아이템을 찾아 삭제합니다.";
Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_REMOVE_RANDOM"] = "리스트에서 랜덤하게 아이템을 삭제합니다.";
Blockly.Msg["LISTS_GET_SUBLIST_END_FROM_END"] = "끝에서부터 # 번째로";
Blockly.Msg["LISTS_GET_SUBLIST_END_FROM_START"] = "앞에서부터 # 번째로";
Blockly.Msg["LISTS_GET_SUBLIST_END_LAST"] = "마지막으로";
Blockly.Msg["LISTS_GET_SUBLIST_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#getting-a-sublist";
Blockly.Msg["LISTS_GET_SUBLIST_IN_LIST"] = "in list";  // untranslated
Blockly.Msg["LISTS_GET_SUBLIST_START_FIRST"] = "첫 번째 위치부터, 서브 리스트 추출";
Blockly.Msg["LISTS_GET_SUBLIST_START_FROM_END"] = "마지막부터 # 번째 위치부터, 서브 리스트 추출";
Blockly.Msg["LISTS_GET_SUBLIST_START_FROM_START"] = "처음 # 번째 위치부터, 서브 리스트 추출";
Blockly.Msg["LISTS_GET_SUBLIST_TAIL"] = "";
Blockly.Msg["LISTS_GET_SUBLIST_TOOLTIP"] = "목록의 특정 부분에 대한 복사본을 만듭니다.";
Blockly.Msg["LISTS_INDEX_FROM_END_TOOLTIP"] = "%1은(는) 마지막 항목입니다.";
Blockly.Msg["LISTS_INDEX_FROM_START_TOOLTIP"] = "%1은 첫 번째 항목입니다.";
Blockly.Msg["LISTS_INDEX_OF_FIRST"] = "처음으로 나타난 위치";
Blockly.Msg["LISTS_INDEX_OF_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#getting-items-from-a-list";
Blockly.Msg["LISTS_INDEX_OF_LAST"] = "마지막으로 나타난 위치";
Blockly.Msg["LISTS_INDEX_OF_TITLE"] = "in list %1 %2 %3";  // untranslated
Blockly.Msg["LISTS_INDEX_OF_TOOLTIP"] = "목록에서 항목이 처음 또는 마지막으로 발생한 색인 위치를 반환합니다. 항목이 없으면 %1을 반환합니다.";
Blockly.Msg["LISTS_INLIST"] = "리스트";
Blockly.Msg["LISTS_INSERT_INDEX_FIRST"] = "at first";  // untranslated
Blockly.Msg["LISTS_INSERT_INDEX_FROM_END"] = "at # from end";  // untranslated
Blockly.Msg["LISTS_INSERT_INDEX_FROM_START"] = "at #";  // untranslated
Blockly.Msg["LISTS_INSERT_INDEX_LAST"] = "at last";  // untranslated
Blockly.Msg["LISTS_INSERT_INDEX_RANDOM"] = "at random";  // untranslated
Blockly.Msg["LISTS_INSERT_INDEX_TITLE"] = "in list %1 insert %2 %3";  // untranslated
Blockly.Msg["LISTS_INSERT_INDEX_TOOLTIP_FIRST"] = "Inserts the item at the start of a list.";  // untranslated
Blockly.Msg["LISTS_INSERT_INDEX_TOOLTIP_FROM"] = "Inserts the item at the specified position in a list.";  // untranslated
Blockly.Msg["LISTS_INSERT_INDEX_TOOLTIP_LAST"] = "Append the item to the end of a list.";  // untranslated
Blockly.Msg["LISTS_INSERT_INDEX_TOOLTIP_RANDOM"] = "Inserts the item randomly in a list.";  // untranslated
Blockly.Msg["LISTS_ISEMPTY_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#is-empty";
Blockly.Msg["LISTS_ISEMPTY_TITLE"] = "%1이 비어 있습니다";
Blockly.Msg["LISTS_ISEMPTY_TOOLTIP"] = "목록이 비었을 때 참을 반환합니다.";
Blockly.Msg["LISTS_LENGTH_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#length-of";
Blockly.Msg["LISTS_LENGTH_TITLE"] = "%1의 길이";
Blockly.Msg["LISTS_LENGTH_TOOLTIP"] = "목록의 길이를 반환합니다.";
Blockly.Msg["LISTS_REPEAT_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#create-list-with";
Blockly.Msg["LISTS_REPEAT_TITLE"] = "%1을 %2번 넣어, 리스트 생성";
Blockly.Msg["LISTS_REPEAT_TOOLTIP"] = "지정된 값을, 지정된 개수 만큼 넣어, 목록을 생성합니다.";
Blockly.Msg["LISTS_REVERSE_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#reversing-a-list";
Blockly.Msg["LISTS_REVERSE_MESSAGE0"] = "%1 뒤집기";
Blockly.Msg["LISTS_REVERSE_TOOLTIP"] = "리스트의 복사본을 뒤집습니다.";
Blockly.Msg["LISTS_SET_INDEX_FIRST"] = "set first";  // untranslated
Blockly.Msg["LISTS_SET_INDEX_FROM_END"] = "set # from end";  // untranslated
Blockly.Msg["LISTS_SET_INDEX_FROM_START"] = "set #";  // untranslated
Blockly.Msg["LISTS_SET_INDEX_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#in-list--set";
Blockly.Msg["LISTS_SET_INDEX_LAST"] = "set last";  // untranslated
Blockly.Msg["LISTS_SET_INDEX_RANDOM"] = "set random";  // untranslated
Blockly.Msg["LISTS_SET_INDEX_TITLE"] = "in list %1 %2 as %3";  // untranslated
Blockly.Msg["LISTS_SET_INDEX_TOOLTIP_FIRST"] = "Sets the first item in a list.";  // untranslated
Blockly.Msg["LISTS_SET_INDEX_TOOLTIP_FROM"] = "Sets the item at the specified position in a list.";  // untranslated
Blockly.Msg["LISTS_SET_INDEX_TOOLTIP_LAST"] = "Sets the last item in a list.";  // untranslated
Blockly.Msg["LISTS_SET_INDEX_TOOLTIP_RANDOM"] = "Sets a random item in a list.";  // untranslated
Blockly.Msg["LISTS_SORT_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#sorting-a-list";
Blockly.Msg["LISTS_SORT_ORDER_ASCENDING"] = "오름차순";
Blockly.Msg["LISTS_SORT_ORDER_DESCENDING"] = "내림차순";
Blockly.Msg["LISTS_SORT_TITLE"] = "정렬 %1 %2 %3";
Blockly.Msg["LISTS_SORT_TOOLTIP"] = "목록의 사본을 정렬합니다.";
Blockly.Msg["LISTS_SORT_TYPE_IGNORECASE"] = "알파벳순 (대소문자 구분 안 함)";
Blockly.Msg["LISTS_SORT_TYPE_NUMERIC"] = "숫자순";
Blockly.Msg["LISTS_SORT_TYPE_TEXT"] = "알파벳순";
Blockly.Msg["LISTS_SPLIT_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#splitting-strings-and-joining-lists";
Blockly.Msg["LISTS_SPLIT_LIST_FROM_TEXT"] = "텍스트에서 목록 만들기";
Blockly.Msg["LISTS_SPLIT_TEXT_FROM_LIST"] = "목록에서 텍스트 만들기";
Blockly.Msg["LISTS_SPLIT_TITLE"] = "%2 %1 with delimiter %3";  // untranslated
Blockly.Msg["LISTS_SPLIT_TOOLTIP_JOIN"] = "구분 기호로 구분하여 텍스트 목록을 하나의 텍스트에 병합합니다.";
Blockly.Msg["LISTS_SPLIT_TOOLTIP_SPLIT"] = "각 속보, 텍스트의 목록들에서 텍스트를 분할합니다.";
Blockly.Msg["LOGIC_BOOLEAN_FALSE"] = "거짓";
Blockly.Msg["LOGIC_BOOLEAN_HELPURL"] = "https://ko.wikipedia.org/wiki/%EC%A7%84%EB%A6%BF%EA%B0%92";
Blockly.Msg["LOGIC_BOOLEAN_TOOLTIP"] = "참 혹은 거짓 모두 반환합니다.";
Blockly.Msg["LOGIC_BOOLEAN_TRUE"] = "참";
Blockly.Msg["LOGIC_COMPARE_HELPURL"] = "https://ko.wikipedia.org/wiki/부등식";
Blockly.Msg["LOGIC_COMPARE_TOOLTIP_EQ"] = "두 값이 같으면, 참(true) 값을 돌려줍니다.";
Blockly.Msg["LOGIC_COMPARE_TOOLTIP_GT"] = "첫 번째 값이 두 번째 값보다 크면, 참(true) 값을 돌려줍니다.";
Blockly.Msg["LOGIC_COMPARE_TOOLTIP_GTE"] = "첫 번째 값이 두 번째 값보다 크거나 같으면, 참(true) 값을 돌려줍니다.";
Blockly.Msg["LOGIC_COMPARE_TOOLTIP_LT"] = "첫 번째 값이 두 번째 값보다 작으면, 참(true) 값을 돌려줍니다.";
Blockly.Msg["LOGIC_COMPARE_TOOLTIP_LTE"] = "첫 번째 값이 두 번째 값보다 작거나 같으면, 참(true) 값을 돌려줍니다.";
Blockly.Msg["LOGIC_COMPARE_TOOLTIP_NEQ"] = "두 값이 서로 다르면, 참(true) 값을 돌려줍니다.";
Blockly.Msg["LOGIC_NEGATE_HELPURL"] = "https://ko.wikipedia.org/wiki/%EB%B6%80%EC%A0%95";
Blockly.Msg["LOGIC_NEGATE_TITLE"] = "%1가 아닙니다";
Blockly.Msg["LOGIC_NEGATE_TOOLTIP"] = "입력값이 거짓이라면 참을 반환합니다. 참이라면 거짓을 반환합니다.";
Blockly.Msg["LOGIC_NULL"] = "빈 값";
Blockly.Msg["LOGIC_NULL_HELPURL"] = "https://en.wikipedia.org/wiki/Nullable_type";
Blockly.Msg["LOGIC_NULL_TOOLTIP"] = "빈 값을 반환합니다.";
Blockly.Msg["LOGIC_OPERATION_AND"] = "그리고";
Blockly.Msg["LOGIC_OPERATION_HELPURL"] = "https://ko.wikipedia.org/wiki/%EB%B6%88_%EB%85%BC%EB%A6%AC";
Blockly.Msg["LOGIC_OPERATION_OR"] = "또는";
Blockly.Msg["LOGIC_OPERATION_TOOLTIP_AND"] = "두 값이 모두 참(true) 값이면, 참 값을 돌려줍니다.";
Blockly.Msg["LOGIC_OPERATION_TOOLTIP_OR"] = "적어도 하나의 값이 참일 경우 참을 반환합니다.";
Blockly.Msg["LOGIC_TERNARY_CONDITION"] = "테스트";
Blockly.Msg["LOGIC_TERNARY_HELPURL"] = "https://ko.wikipedia.org/wiki/물음표";
Blockly.Msg["LOGIC_TERNARY_IF_FALSE"] = "만약 거짓이라면";
Blockly.Msg["LOGIC_TERNARY_IF_TRUE"] = "만약 참이라면";
Blockly.Msg["LOGIC_TERNARY_TOOLTIP"] = "'test'의 조건을 검사합니다. 조건이 참이면 'if true' 값을 반환합니다. 거짓이면 'if false' 값을 반환합니다.";
Blockly.Msg["MATH_ADDITION_SYMBOL"] = "+";
Blockly.Msg["MATH_ARITHMETIC_HELPURL"] = "https://ko.wikipedia.org/wiki/산술";
Blockly.Msg["MATH_ARITHMETIC_TOOLTIP_ADD"] = "두 수의 합을 반환합니다.";
Blockly.Msg["MATH_ARITHMETIC_TOOLTIP_DIVIDE"] = "두 수의 나눈 결과를 반환합니다.";
Blockly.Msg["MATH_ARITHMETIC_TOOLTIP_MINUS"] = "두 수간의 차이를 반환합니다.";
Blockly.Msg["MATH_ARITHMETIC_TOOLTIP_MULTIPLY"] = "두 수의 곱을 반환합니다.";
Blockly.Msg["MATH_ARITHMETIC_TOOLTIP_POWER"] = "첫 번째 수를 두 번째 수 만큼, 거듭제곱 한 결과값을 돌려줍니다.";
Blockly.Msg["MATH_ATAN2_HELPURL"] = "https://en.wikipedia.org/wiki/Atan2";
Blockly.Msg["MATH_ATAN2_TITLE"] = "X:%1 Y:%2의 atan2";
Blockly.Msg["MATH_ATAN2_TOOLTIP"] = "점 (X, Y)의 아크탄젠트를 -180에서 180까지 도 단위로 반환합니다.";
Blockly.Msg["MATH_CHANGE_HELPURL"] = "https://en.wikipedia.org/wiki/Programming_idiom#Incrementing_a_counter";
Blockly.Msg["MATH_CHANGE_TITLE"] = "바꾸기 %1 만큼 %2";
Blockly.Msg["MATH_CHANGE_TOOLTIP"] = "변수 '%1' 에 저장되어있는 값에, 어떤 수를 더해, 변수에 다시 저장합니다.";
Blockly.Msg["MATH_CONSTANT_HELPURL"] = "https://ko.wikipedia.org/wiki/수학_상수";
Blockly.Msg["MATH_CONSTANT_TOOLTIP"] = "일반적인 상수 값들 중 하나를 돌려줍니다. : π (3.141…), e (2.718…), φ (1.618…), sqrt(2) (1.414…), sqrt(½) (0.707…), or ∞ (infinity).";
Blockly.Msg["MATH_CONSTRAIN_HELPURL"] = "https://ko.wikipedia.org/wiki/클램핑_(그래픽)";
Blockly.Msg["MATH_CONSTRAIN_TITLE"] = "%1의 값을, 최소 %2 최대 %3으로 조정";
Blockly.Msg["MATH_CONSTRAIN_TOOLTIP"] = "어떤 수를, 특정 범위의 값이 되도록 강제로 조정합니다.";
Blockly.Msg["MATH_CONVERT_TITLE"] = "conver %1 to %2";  // untranslated
Blockly.Msg["MATH_CONVERT_TOOLTIP"] = "Convert a string to integer of floating point number.";  // untranslated
Blockly.Msg["MATH_DIVISION_SYMBOL"] = "÷";
Blockly.Msg["MATH_FLOAT"] = "floating-point number";  // untranslated
Blockly.Msg["MATH_INT"] = "integer";  // untranslated
Blockly.Msg["MATH_IS_DIVISIBLE_BY"] = "가 다음 수로 나누어 떨어지면 :";
Blockly.Msg["MATH_IS_EVEN"] = "가 짝수(even) 이면";
Blockly.Msg["MATH_IS_NEGATIVE"] = "가 음(-)수 이면";
Blockly.Msg["MATH_IS_ODD"] = "가 홀수(odd) 이면";
Blockly.Msg["MATH_IS_POSITIVE"] = "가 양(+)수 이면";
Blockly.Msg["MATH_IS_PRIME"] = "가 소수(prime) 이면";
Blockly.Msg["MATH_IS_TOOLTIP"] = "어떤 수가 짝 수, 홀 수, 소 수, 정 수, 양 수, 음 수, 나누어 떨어지는 수 인지 검사해 결과값을 돌려줍니다. 참(true) 또는 거짓(false) 값을 돌려줌.";
Blockly.Msg["MATH_IS_WHOLE"] = "가 정수이면";
Blockly.Msg["MATH_MODULO_HELPURL"] = "https://en.wikipedia.org/wiki/Modulo_operation";
Blockly.Msg["MATH_MODULO_TITLE"] = "%1 ÷ %2의 나머지";
Blockly.Msg["MATH_MODULO_TOOLTIP"] = "첫 번째 수를 두 번째 수로 나눈, 나머지 값을 돌려줍니다.";
Blockly.Msg["MATH_MULTIPLICATION_SYMBOL"] = "x";
Blockly.Msg["MATH_NUMBER_HELPURL"] = "https://ko.wikipedia.org/wiki/수_(수학)";
Blockly.Msg["MATH_NUMBER_TOOLTIP"] = "수";
Blockly.Msg["MATH_ONLIST_HELPURL"] = "";
Blockly.Msg["MATH_ONLIST_OPERATOR_AVERAGE"] = "평균값";
Blockly.Msg["MATH_ONLIST_OPERATOR_MAX"] = "최대값";
Blockly.Msg["MATH_ONLIST_OPERATOR_MEDIAN"] = "중간값";
Blockly.Msg["MATH_ONLIST_OPERATOR_MIN"] = "최소값";
Blockly.Msg["MATH_ONLIST_OPERATOR_MODE"] = "가장 여러 개 있는 값";
Blockly.Msg["MATH_ONLIST_OPERATOR_RANDOM"] = "목록의 임의 항목";
Blockly.Msg["MATH_ONLIST_OPERATOR_STD_DEV"] = "표준 편차";
Blockly.Msg["MATH_ONLIST_OPERATOR_SUM"] = "합";
Blockly.Msg["MATH_ONLIST_TITLE"] = "%1 %2";  // untranslated
Blockly.Msg["MATH_ONLIST_TOOLTIP_AVERAGE"] = "리스트에 들어있는 수(값)들에 대해, 산술 평균(arithmetic mean) 한 값을 돌려줍니다.";
Blockly.Msg["MATH_ONLIST_TOOLTIP_MAX"] = "리스트에 들어있는 수(값) 들 중, 가장 큰(max) 수(값)를 돌려줍니다.";
Blockly.Msg["MATH_ONLIST_TOOLTIP_MEDIAN"] = "리스트에 들어있는 수(값) 들 중, 중간(median) 수(값)를 돌려줍니다.";
Blockly.Msg["MATH_ONLIST_TOOLTIP_MIN"] = "리스트에 들어있는 수(값) 들 중, 가장 작은(min) 수(값)를 돌려줍니다.";
Blockly.Msg["MATH_ONLIST_TOOLTIP_MODE"] = "리스트에 들어있는 아이템들 중에서, 가장 여러 번 들어있는 아이템들을 리스트로 만들어 돌려줍니다. (최빈값, modes)";
Blockly.Msg["MATH_ONLIST_TOOLTIP_RANDOM"] = "목록에서 임의의 아이템을 돌려줍니다.";
Blockly.Msg["MATH_ONLIST_TOOLTIP_STD_DEV"] = "이 리스트의 표준 편차를 반환합니다.";
Blockly.Msg["MATH_ONLIST_TOOLTIP_SUM"] = "리스트에 들어있는 수(값)들을, 모두 합(sum) 한, 총합(sum)을 돌려줍니다.";
Blockly.Msg["MATH_POWER_SYMBOL"] = "^";
Blockly.Msg["MATH_RANDOM_FLOAT_HELPURL"] = "https://en.wikipedia.org/wiki/Random_number_generation";
Blockly.Msg["MATH_RANDOM_FLOAT_TITLE_RANDOM"] = "임의 분수";
Blockly.Msg["MATH_RANDOM_FLOAT_TOOLTIP"] = "0.0 (포함)과 1.0 (배타적) 사이의 임의 분수 값을 돌려줍니다.";
Blockly.Msg["MATH_RANDOM_INT_HELPURL"] = "https://en.wikipedia.org/wiki/Random_number_generation";
Blockly.Msg["MATH_RANDOM_INT_TITLE"] = "랜덤정수(%1<= n <=%2)";
Blockly.Msg["MATH_RANDOM_INT_TOOLTIP"] = "두 주어진 제한된 범위 사이의 임의 정수값을 돌려줍니다.";
Blockly.Msg["MATH_ROUND_HELPURL"] = "https://ko.wikipedia.org/wiki/반올림";
Blockly.Msg["MATH_ROUND_OPERATOR_ROUND"] = "반올림";
Blockly.Msg["MATH_ROUND_OPERATOR_ROUNDDOWN"] = "버림";
Blockly.Msg["MATH_ROUND_OPERATOR_ROUNDUP"] = "올림";
Blockly.Msg["MATH_ROUND_TOOLTIP"] = "어떤 수를 반올림/올림/버림한 결과를, 정수값으로 돌려줍니다.";
Blockly.Msg["MATH_SINGLE_HELPURL"] = "https://ko.wikipedia.org/wiki/제곱근";
Blockly.Msg["MATH_SINGLE_OP_ABSOLUTE"] = "절대값";
Blockly.Msg["MATH_SINGLE_OP_ROOT"] = "제곱근";
Blockly.Msg["MATH_SINGLE_TOOLTIP_ABS"] = "어떤 수의 절대값(absolute)을 계산한 결과를, 정수값으로 돌려줍니다.";
Blockly.Msg["MATH_SINGLE_TOOLTIP_EXP"] = "e의 거듭제곱 값을 반환합니다.";
Blockly.Msg["MATH_SINGLE_TOOLTIP_LN"] = "어떤 수의, 자연로그(natural logarithm) 값을 돌려줍니다.(밑 e, 예시 log e x)";
Blockly.Msg["MATH_SINGLE_TOOLTIP_LOG10"] = "어떤 수의, 기본로그(logarithm) 값을 돌려줍니다.(밑 10, 예시 log 10 x)";
Blockly.Msg["MATH_SINGLE_TOOLTIP_NEG"] = "음(-)/양(+), 부호를 반대로 하여 값을 돌려줍니다.";
Blockly.Msg["MATH_SINGLE_TOOLTIP_POW10"] = "10의 거듭제곱 값을 반환합니다.";
Blockly.Msg["MATH_SINGLE_TOOLTIP_ROOT"] = "숫자의 제곱근을 반환합니다.";
Blockly.Msg["MATH_SUBTRACTION_SYMBOL"] = "-";
Blockly.Msg["MATH_TRIG_ACOS"] = "acos";
Blockly.Msg["MATH_TRIG_ASIN"] = "asin";
Blockly.Msg["MATH_TRIG_ATAN"] = "atan";
Blockly.Msg["MATH_TRIG_COS"] = "cos";
Blockly.Msg["MATH_TRIG_HELPURL"] = "https://ko.wikipedia.org/wiki/삼각함수";
Blockly.Msg["MATH_TRIG_SIN"] = "sin";
Blockly.Msg["MATH_TRIG_TAN"] = "tan";
Blockly.Msg["MATH_TRIG_TOOLTIP_ACOS"] = "어떤 수에 대한, acos(arccosine) 값을 돌려줍니다.";
Blockly.Msg["MATH_TRIG_TOOLTIP_ASIN"] = "어떤 수에 대한, asin(arcsine) 값을 돌려줍니다.";
Blockly.Msg["MATH_TRIG_TOOLTIP_ATAN"] = "어떤 수에 대한, atan(arctangent) 값을 돌려줍니다.";
Blockly.Msg["MATH_TRIG_TOOLTIP_COS"] = "각도의 코사인을 반환합니다. (라디안 아님)";
Blockly.Msg["MATH_TRIG_TOOLTIP_SIN"] = "각도의 사인을 반환합니다. (라디안 아님)";
Blockly.Msg["MATH_TRIG_TOOLTIP_TAN"] = "각도의 탄젠트를 반환합니다. (라디안 아님)";
Blockly.Msg["MLPLAY_ALPHA_KEYS"] = "alphabet";  // untranslated
Blockly.Msg["MLPLAY_ARROW_KEYS"] = "arrow key";  // untranslated
Blockly.Msg["MLPLAY_CLASS_INITIALIZE"] = "initialize: ";  // untranslated
Blockly.Msg["MLPLAY_CLASS_RESET"] = "reset: ";  // untranslated
Blockly.Msg["MLPLAY_CLASS_TOOLTIP"] = "The main block for playing the game.\nThe program in the \"initialize\" section will be executed once before the game starts.\nThe program in the \"update\" section will be executed once every frame in the game. You can get the current scene information in the game here, and return the next action.\nAfter the game is over, the program in the \"reset\" will be executed once before the next game starts.";  // untranslated
Blockly.Msg["MLPLAY_CLASS_UPDATE"] = "update: ";  // untranslated
Blockly.Msg["MLPLAY_CLASS_WARNING"] = "Warning: Cannot exist more than one MLPlay block.";  // untranslated
Blockly.Msg["MLPLAY_GAME_STATUS"] = "game";  // untranslated
Blockly.Msg["MLPLAY_GAME_STATUS_TOOLTIP"] = "Options to determine the game status.";  // untranslated
Blockly.Msg["MLPLAY_GET_CONSTANT"] = "constant";  // untranslated
Blockly.Msg["MLPLAY_GET_CONSTANT_TOOLTIP"] = "Get the constants of game environment.";  // untranslated
Blockly.Msg["MLPLAY_GET_INFO"] = "get";  // untranslated
Blockly.Msg["MLPLAY_GET_INFO_TOOLTIP"] = "Get scene information in the game.";  // untranslated
Blockly.Msg["MLPLAY_GET_INFO_WARNING"] = "Warning: Cannot get game information outside the \"update\" section of MLPlay block.";  // untranslated
Blockly.Msg["MLPLAY_INIT_INFO"] = "Initial information";  // untranslated
Blockly.Msg["MLPLAY_INIT_INFO_TOOLTIP"] = "Get initial information of the game";  // untranslated
Blockly.Msg["MLPLAY_INIT_INFO_WARNING"] = "Warning: Cannot get initial information outside the \"initialize\" section of MLPlay block.";  // untranslated
Blockly.Msg["MLPLAY_IS_KEY_PRESSED_TOOLTIP"] = "Return the key is pressed or not.";  // untranslated
Blockly.Msg["MLPLAY_KEY_PRESSED"] = "is pressed";  // untranslated
Blockly.Msg["MLPLAY_NUMBER_KEYS"] = "number";  // untranslated
Blockly.Msg["MLPLAY_PLAYER_STATUS"] = "Player";  // untranslated
Blockly.Msg["MLPLAY_PLAYER_STATUS_TOOLTIP"] = "Options to determine the player.";  // untranslated
Blockly.Msg["MLPLAY_RETURN_ACTION"] = "return action";  // untranslated
Blockly.Msg["MLPLAY_RETURN_ACTION_TOOLTIP"] = "Return the next action, or return the reset command after the game is over.";  // untranslated
Blockly.Msg["MLPLAY_RETURN_ACTION_WARNING"] = "Warning: Cannot return an action outside the \"update\" section of MLPlay block.";  // untranslated
Blockly.Msg["MLPLAY_RETURN_MAZECAR_ACTION"] = "return speed of left motor: %1 right motor: %2";  // untranslated
Blockly.Msg["MODEL_ACTIVATION"] = "activation function";  // untranslated
Blockly.Msg["MODEL_ACTIVATION_LOGISTIC"] = "logistic";  // untranslated
Blockly.Msg["MODEL_ACTIVATION_RELU"] = "ReLU";  // untranslated
Blockly.Msg["MODEL_ACTIVATION_TANH"] = "tanh";  // untranslated
Blockly.Msg["MODEL_ALGORITHM"] = "algorithm";  // untranslated
Blockly.Msg["MODEL_ALGORITHM_AUTO"] = "auto";  // untranslated
Blockly.Msg["MODEL_ALGORITHM_BALL_TREE"] = "ball tree";  // untranslated
Blockly.Msg["MODEL_ALGORITHM_BRUTE"] = "brute-force search";  // untranslated
Blockly.Msg["MODEL_ALGORITHM_KD_TREE"] = "k-d tree";  // untranslated
Blockly.Msg["MODEL_BATCH_SIZE"] = "batch size";  // untranslated
Blockly.Msg["MODEL_C"] = "C";  // untranslated
Blockly.Msg["MODEL_CLASSIFICATION"] = "classification model";  // untranslated
Blockly.Msg["MODEL_CREATE"] = "create";  // untranslated
Blockly.Msg["MODEL_CREATE_CLASSIFICATION_TOOLTIP"] = "Create different types of classification model and set its parameters.";  // untranslated
Blockly.Msg["MODEL_CREATE_REGRESSION_TOOLTIP"] = "Create different types of regression model and set its parameters.";  // untranslated
Blockly.Msg["MODEL_DECISION_TREE"] = "decision tree";  // untranslated
Blockly.Msg["MODEL_EVALUATE_CLASSIFICATION"] = "use true results：%1 predicted results：%2 to evaluate accuracy of classification results";  // untranslated
Blockly.Msg["MODEL_EVALUATE_CLASSIFICATION_TOOLTIP"] = "Calculate the proportion of the predicted classification results that is the same as the true results.";  // untranslated
Blockly.Msg["MODEL_EVALUATE_MAE"] = "mean absolute error";  // untranslated
Blockly.Msg["MODEL_EVALUATE_MSE"] = "mean squared error";  // untranslated
Blockly.Msg["MODEL_EVALUATE_R2"] = "coefficient of determination";  // untranslated
Blockly.Msg["MODEL_EVALUATE_REGRESSION"] = "use true results：%1 predicted results：%2 to evaluate %3 of regression results";  // untranslated
Blockly.Msg["MODEL_EVALUATE_REGRESSION_TOOLTIP"] = "Calculate the mean absolute error or mean squared error between the predicted regression results and the true results.";  // untranslated
Blockly.Msg["MODEL_EVALUATE_TOOLTIP"] = "Evaluate the predicted results according to the true results.";  // untranslated
Blockly.Msg["MODEL_HIDDEN_LAYER_SIZES"] = "hidden layer sizes";  // untranslated
Blockly.Msg["MODEL_KNN"] = "k-nearest neighbors";  // untranslated
Blockly.Msg["MODEL_K_FOLD"] = "split training data: %1 target values: %2 for %3-fold cross-validation %4";  // untranslated
Blockly.Msg["MODEL_K_FOLD_TOOLTIP"] = "Perform k-fold cross-validation on the training data randomly or sequentially. This block will return k lists of length 4, including training data, testing data, training targets, and testing targets for each cross-validation.";  // untranslated
Blockly.Msg["MODEL_LINEAR_SVM"] = "linear support vector machine";  // untranslated
Blockly.Msg["MODEL_LOSS"] = "loss funciton";  // untranslated
Blockly.Msg["MODEL_LOSS_EPSILON_INSENSITIVE"] = "linear support vector regression";  // untranslated
Blockly.Msg["MODEL_LOSS_HINGE"] = "hinge loss";  // untranslated
Blockly.Msg["MODEL_LOSS_HUBER"] = "huber loss";  // untranslated
Blockly.Msg["MODEL_LOSS_LOG"] = "logistic regression";  // untranslated
Blockly.Msg["MODEL_LOSS_MODIFIED_HUBER"] = "smoothed hinge loss";  // untranslated
Blockly.Msg["MODEL_LOSS_SQUARED_HINGE"] = "square of hinge loss";  // untranslated
Blockly.Msg["MODEL_LOSS_SQUARED_LOSS"] = "ordinary least squares";  // untranslated
Blockly.Msg["MODEL_MAX_DEPTH"] = "max depth";  // untranslated
Blockly.Msg["MODEL_MIN_SAMPLES_SPLIT"] = "minimum samples required to split";  // untranslated
Blockly.Msg["MODEL_MLP"] = "multilayer perceptron";  // untranslated
Blockly.Msg["MODEL_NO_SHUFFLE"] = "without shuffling";  // untranslated
Blockly.Msg["MODEL_N_ESTIMATORS"] = "number of trees";  // untranslated
Blockly.Msg["MODEL_PENALTY"] = "penalty function";  // untranslated
Blockly.Msg["MODEL_PENALTY_L1"] = "L1 Norm";  // untranslated
Blockly.Msg["MODEL_PENALTY_L2"] = "L2 Norm";  // untranslated
Blockly.Msg["MODEL_PREDICT"] = "use %1 to predict the target for %2";  // untranslated
Blockly.Msg["MODEL_PREDICT_TOOLTIP"] = "Use the trained model to redict the target fro the provided data. The output is a list of the length that equals to the provided data.";  // untranslated
Blockly.Msg["MODEL_RANDOM_FOREST"] = "random forest";  // untranslated
Blockly.Msg["MODEL_REGRESSION"] = "regression model";  // untranslated
Blockly.Msg["MODEL_SGD"] = "stochastic gradient descent";  // untranslated
Blockly.Msg["MODEL_SHUFFLE"] = "after shuffling";  // untranslated
Blockly.Msg["MODEL_TRAIN"] = "use training data: %1 target values: %2 to train %3";  // untranslated
Blockly.Msg["MODEL_TRAIN_TEST_SPLIT"] = "split training data: %1 target values: %2 into %5, %6, %7, %8 with the ratio of %3 %4";  // untranslated
Blockly.Msg["MODEL_TRAIN_TEST_SPLIT_TOOLTIP"] = "Split a certain proportion from the data randomly or sequentially as the test data. This block will return a list of length 4, including the split training data, testing data, training targets, and testing targets.";  // untranslated
Blockly.Msg["MODEL_TRAIN_TOOLTIP"] = "Train the model to predeict target values from training data, both training data and target values should be lists of the same length.";  // untranslated
Blockly.Msg["MODEL_WEIGHT"] = "weights";  // untranslated
Blockly.Msg["MODEL_WEIGHT_DISTANCE"] = "inverse of distance";  // untranslated
Blockly.Msg["MODEL_WEIGHT_UNIFORM"] = "uniform";  // untranslated
Blockly.Msg["NDARRAYS_CREATE_EMPTY_TITLE"] = "create empty ndarray";  // untranslated
Blockly.Msg["NDARRAYS_CREATE_FILL_WITH"] = "filled with";  // untranslated
Blockly.Msg["NDARRAYS_CREATE_WITH_CONTAINER"] = "ndarray";  // untranslated
Blockly.Msg["NDARRAYS_CREATE_WITH_CONTAINER_TOOLTIP"] = "Add, remove, or reorder dimensions to reconfigure this ndarray block.";  // untranslated
Blockly.Msg["NDARRAYS_CREATE_WITH_DIM"] = "dimension";  // untranslated
Blockly.Msg["NDARRAYS_CREATE_WITH_DIM_TOOLTIP"] = "Add a dimension to the ndarray.";  // untranslated
Blockly.Msg["NDARRAYS_CREATE_WITH_DIM_WITH"] = "create ndarray of shape";  // untranslated
Blockly.Msg["NDARRAYS_CREATE_WITH_LIST"] = "create ndarray from %1";  // untranslated
Blockly.Msg["NDARRAYS_CREATE_WITH_LIST_TOOLTIP"] = "Create an ndarray from a list.";  // untranslated
Blockly.Msg["NDARRAYS_CREATE_WITH_TOOLTIP"] = "Create an ndarray with any shape.";  // untranslated
Blockly.Msg["NDARRAYS_TO_LIST"] = "convert %1 to list";  // untranslated
Blockly.Msg["NDARRAYS_TO_LIST_TOOLTIP"] = "Return a copy of the ndarray data as a nested list.";  // untranslated
Blockly.Msg["NEW_COLOUR_VARIABLE"] = "색 변수 만들기...";
Blockly.Msg["NEW_NUMBER_VARIABLE"] = "숫자 변수 만들기....";
Blockly.Msg["NEW_STRING_VARIABLE"] = "문자열 변수 만들기...";
Blockly.Msg["NEW_VARIABLE"] = "변수 만들기...";
Blockly.Msg["NEW_VARIABLE_TITLE"] = "새 변수 이름:";
Blockly.Msg["NEW_VARIABLE_TYPE_TITLE"] = "새 변수 유형:";
Blockly.Msg["ORDINAL_NUMBER_SUFFIX"] = "";
Blockly.Msg["PLOT_PLOT"] = "plot X: %1 Y: %2 marker: %3 line: %4 color: %5";  // untranslated
Blockly.Msg["PLOT_PLOT_TOOLTIP"] = "Plot with given X, Y and style.";  // untranslated
Blockly.Msg["PROCEDURES_ALLOW_STATEMENTS"] = "서술 허가";
Blockly.Msg["PROCEDURES_BEFORE_PARAMS"] = "사용:";
Blockly.Msg["PROCEDURES_CALLNORETURN_HELPURL"] = "https://ko.wikipedia.org/wiki/함수_(프로그래밍)";
Blockly.Msg["PROCEDURES_CALLNORETURN_TOOLTIP"] = "미리 정의해 둔 '%1' 함수를 실행합니다.";
Blockly.Msg["PROCEDURES_CALLRETURN_HELPURL"] = "https://ko.wikipedia.org/wiki/함수_(프로그래밍)";
Blockly.Msg["PROCEDURES_CALLRETURN_TOOLTIP"] = "미리 정의해 둔 '%1' 함수를 실행하고, 함수를 실행한 결과 값을 돌려줍니다.";
Blockly.Msg["PROCEDURES_CALL_BEFORE_PARAMS"] = "사용:";
Blockly.Msg["PROCEDURES_CREATE_DO"] = "'%1' 생성";
Blockly.Msg["PROCEDURES_DEFNORETURN_COMMENT"] = "이 함수를 설명하세요...";
Blockly.Msg["PROCEDURES_DEFNORETURN_DO"] = "";
Blockly.Msg["PROCEDURES_DEFNORETURN_HELPURL"] = "https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98_%28%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%29";
Blockly.Msg["PROCEDURES_DEFNORETURN_PROCEDURE"] = "함수 이름";
Blockly.Msg["PROCEDURES_DEFNORETURN_TITLE"] = "함수";
Blockly.Msg["PROCEDURES_DEFNORETURN_TOOLTIP"] = "실행 후, 결과 값을 돌려주지 않는 함수를 만듭니다.";
Blockly.Msg["PROCEDURES_DEFRETURN_HELPURL"] = "https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98_%28%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%29";
Blockly.Msg["PROCEDURES_DEFRETURN_RETURN"] = "다음을 돌려줌";
Blockly.Msg["PROCEDURES_DEFRETURN_TOOLTIP"] = "실행 후, 결과 값을 돌려주는 함수를 만듭니다.";
Blockly.Msg["PROCEDURES_DEF_DUPLICATE_WARNING"] = "경고: 이 함수에는, 같은 이름을 사용하는 매개 변수들이 있습니다.";
Blockly.Msg["PROCEDURES_HIGHLIGHT_DEF"] = "함수 정의 찾기";
Blockly.Msg["PROCEDURES_IFRETURN_HELPURL"] = "http://c2.com/cgi/wiki?GuardClause";
Blockly.Msg["PROCEDURES_IFRETURN_TOOLTIP"] = "값이 참이라면, 두 번째 값을 반환합니다.";
Blockly.Msg["PROCEDURES_IFRETURN_WARNING"] = "경고: 이 블럭은, 함수 정의 블럭 안에서만 사용할 수 있습니다.";
Blockly.Msg["PROCEDURES_MUTATORARG_TITLE"] = "매개 변수:";
Blockly.Msg["PROCEDURES_MUTATORARG_TOOLTIP"] = "함수에 값을 더합니다.";
Blockly.Msg["PROCEDURES_MUTATORCONTAINER_TITLE"] = "매개 변수들";
Blockly.Msg["PROCEDURES_MUTATORCONTAINER_TOOLTIP"] = "이 함수를 추가, 삭제, 혹은 재정렬합니다.";
Blockly.Msg["REDO"] = "다시 실행";
Blockly.Msg["REMOVE_COMMENT"] = "주석 제거";
Blockly.Msg["RENAME_VARIABLE"] = "변수 이름 바꾸기:";
Blockly.Msg["RENAME_VARIABLE_TITLE"] = "'%1' 변수 이름을 바꾸기:";
Blockly.Msg["TEXT_APPEND_HELPURL"] = "https://github.com/google/blockly/wiki/Text#text-modification";
Blockly.Msg["TEXT_APPEND_TITLE"] = "다음 %1 내용 덧붙이기 %2";
Blockly.Msg["TEXT_APPEND_TOOLTIP"] = "'%1' 변수의 끝에 일부 텍스트를 덧붙입니다.";
Blockly.Msg["TEXT_CHANGECASE_HELPURL"] = "https://github.com/google/blockly/wiki/Text#adjusting-text-case";
Blockly.Msg["TEXT_CHANGECASE_OPERATOR_LOWERCASE"] = "소문자로";
Blockly.Msg["TEXT_CHANGECASE_OPERATOR_TITLECASE"] = "첫 문자만 대문자로";
Blockly.Msg["TEXT_CHANGECASE_OPERATOR_UPPERCASE"] = "대문자로";
Blockly.Msg["TEXT_CHANGECASE_TITLE"] = "%2 %1";  // untranslated
Blockly.Msg["TEXT_CHANGECASE_TOOLTIP"] = "영문 대소문자 형태를 변경해 돌려줍니다.";
Blockly.Msg["TEXT_CHARAT_FIRST"] = "에서, 첫 번째 문자 얻기";
Blockly.Msg["TEXT_CHARAT_FROM_END"] = "에서, 마지막부터 # 번째 위치의 문자 얻기";
Blockly.Msg["TEXT_CHARAT_FROM_START"] = "에서, 앞에서부터 # 번째 위치의 문자 얻기";
Blockly.Msg["TEXT_CHARAT_HELPURL"] = "https://github.com/google/blockly/wiki/Text#extracting-text";
Blockly.Msg["TEXT_CHARAT_LAST"] = "에서, 마지막 문자 얻기";
Blockly.Msg["TEXT_CHARAT_RANDOM"] = "에서, 랜덤하게 한 문자 얻기";
Blockly.Msg["TEXT_CHARAT_TAIL"] = "";
Blockly.Msg["TEXT_CHARAT_TITLE"] = "텍스트 %1 %2에서";
Blockly.Msg["TEXT_CHARAT_TOOLTIP"] = "특정 번째 위치에서, 문자를 얻어내 돌려줍니다.";
Blockly.Msg["TEXT_COUNT_HELPURL"] = "https://github.com/google/blockly/wiki/Text#counting-substrings";
Blockly.Msg["TEXT_COUNT_MESSAGE0"] = "%2에서 %1 숫자 세기";
Blockly.Msg["TEXT_COUNT_TOOLTIP"] = "다른 어떤 텍스트에서 어떤 텍스트가 나타난 횟수를 셉니다.";
Blockly.Msg["TEXT_CREATE_JOIN_ITEM_TOOLTIP"] = "텍스트에 항목을 추가합니다.";
Blockly.Msg["TEXT_CREATE_JOIN_TITLE_JOIN"] = "가입";
Blockly.Msg["TEXT_CREATE_JOIN_TOOLTIP"] = "섹션을 추가, 제거하거나 순서를 변경하여 이 텍스트 블럭을 재구성합니다.";
Blockly.Msg["TEXT_GET_SUBSTRING_END_FROM_END"] = "끝에서부터 # 번째 문자까지";
Blockly.Msg["TEXT_GET_SUBSTRING_END_FROM_START"] = "# 번째 문자까지";
Blockly.Msg["TEXT_GET_SUBSTRING_END_LAST"] = "마지막 문자까지";
Blockly.Msg["TEXT_GET_SUBSTRING_HELPURL"] = "https://github.com/google/blockly/wiki/Text#extracting-a-region-of-text";
Blockly.Msg["TEXT_GET_SUBSTRING_INPUT_IN_TEXT"] = "문장";
Blockly.Msg["TEXT_GET_SUBSTRING_START_FIRST"] = "에서, 처음부터 얻어냄";
Blockly.Msg["TEXT_GET_SUBSTRING_START_FROM_END"] = "에서, 마지막에서 # 번째부터 얻어냄";
Blockly.Msg["TEXT_GET_SUBSTRING_START_FROM_START"] = "에서, 처음부터 # 번째 문자부터 얻어냄";
Blockly.Msg["TEXT_GET_SUBSTRING_TAIL"] = "";
Blockly.Msg["TEXT_GET_SUBSTRING_TOOLTIP"] = "문장 중 일부를 얻어내 돌려줍니다.";
Blockly.Msg["TEXT_INDEXOF_HELPURL"] = "https://github.com/google/blockly/wiki/Text#finding-text";
Blockly.Msg["TEXT_INDEXOF_OPERATOR_FIRST"] = "에서 다음 문장이 처음으로 나타난 위치 찾기 :";
Blockly.Msg["TEXT_INDEXOF_OPERATOR_LAST"] = "에서 다음 문장이 마지막으로 나타난 위치 찾기 :";
Blockly.Msg["TEXT_INDEXOF_TITLE"] = "문장 %1 %2 %3";
Blockly.Msg["TEXT_INDEXOF_TOOLTIP"] = "두 번째 텍스트에서 첫 번째 텍스트가 처음 또는 마지막으로 발생한 색인 위치를 반환합니다. 텍스트가 없으면 %1을 반환합니다.";
Blockly.Msg["TEXT_ISEMPTY_HELPURL"] = "https://github.com/google/blockly/wiki/Text#checking-for-empty-text";
Blockly.Msg["TEXT_ISEMPTY_TITLE"] = "%1이 비어 있습니다";
Blockly.Msg["TEXT_ISEMPTY_TOOLTIP"] = "입력된 문장이, 빈 문장(\"\")이면 참(true) 값을 돌려줍니다.";
Blockly.Msg["TEXT_JOIN_HELPURL"] = "https://github.com/google/blockly/wiki/Text#text-creation";
Blockly.Msg["TEXT_JOIN_TITLE_CREATEWITH"] = "텍스트 만들기";
Blockly.Msg["TEXT_JOIN_TOOLTIP"] = "여러 개의 아이템들을 연결해(묶어), 새로운 문장을 만듭니다.";
Blockly.Msg["TEXT_LENGTH_HELPURL"] = "https://github.com/google/blockly/wiki/Text#text-modification";
Blockly.Msg["TEXT_LENGTH_TITLE"] = "다음 문장의 문자 개수 %1";
Blockly.Msg["TEXT_LENGTH_TOOLTIP"] = "입력된 문장의, 문자 개수를 돌려줍니다.(공백문자 포함)";
Blockly.Msg["TEXT_PRINT_HELPURL"] = "https://github.com/google/blockly/wiki/Text#printing-text";
Blockly.Msg["TEXT_PRINT_TITLE"] = "다음 내용 출력 %1";
Blockly.Msg["TEXT_PRINT_TOOLTIP"] = "원하는 문장, 수, 값 등을 출력합니다.";
Blockly.Msg["TEXT_PROMPT_HELPURL"] = "https://github.com/google/blockly/wiki/Text#getting-input-from-the-user";
Blockly.Msg["TEXT_PROMPT_TOOLTIP_NUMBER"] = "수에 대해 사용자의 입력을 받습니다.";
Blockly.Msg["TEXT_PROMPT_TOOLTIP_TEXT"] = "문장에 대해 사용자의 입력을 받습니다.";
Blockly.Msg["TEXT_PROMPT_TYPE_NUMBER"] = "메시지를 활용해 수 입력";
Blockly.Msg["TEXT_PROMPT_TYPE_TEXT"] = "메시지를 활용해 문장 입력";
Blockly.Msg["TEXT_REPLACE_HELPURL"] = "https://github.com/google/blockly/wiki/Text#replacing-substrings";
Blockly.Msg["TEXT_REPLACE_MESSAGE0"] = "%3에서 %2을(를) %1(으)로 바꾸기";
Blockly.Msg["TEXT_REPLACE_TOOLTIP"] = "다른 텍스트 내에서 일부 텍스트의 모든 발생을 치환합니다.";
Blockly.Msg["TEXT_REVERSE_HELPURL"] = "https://github.com/google/blockly/wiki/Text#reversing-text";
Blockly.Msg["TEXT_REVERSE_MESSAGE0"] = "%1 뒤집기";
Blockly.Msg["TEXT_REVERSE_TOOLTIP"] = "텍스트 안의 문자의 순서를 반전시킵니다.";
Blockly.Msg["TEXT_TEXT_HELPURL"] = "https://ko.wikipedia.org/wiki/문자열";
Blockly.Msg["TEXT_TEXT_TOOLTIP"] = "문자, 단어, 문장.";
Blockly.Msg["TEXT_TRIM_HELPURL"] = "https://github.com/google/blockly/wiki/Text#trimming-removing-spaces";
Blockly.Msg["TEXT_TRIM_OPERATOR_BOTH"] = "양쪽의 공백 문자 제거";
Blockly.Msg["TEXT_TRIM_OPERATOR_LEFT"] = "왼쪽의 공백 문자 제거";
Blockly.Msg["TEXT_TRIM_OPERATOR_RIGHT"] = "오른쪽의 공백 문자 제거";
Blockly.Msg["TEXT_TRIM_TITLE"] = "%2 %1";  // untranslated
Blockly.Msg["TEXT_TRIM_TOOLTIP"] = "문장의 왼쪽/오른쪽/양쪽에서 스페이스 문자를 제거해 돌려줍니다.";
Blockly.Msg["TODAY"] = "오늘";
Blockly.Msg["UNDO"] = "실행 취소";
Blockly.Msg["UNNAMED_KEY"] = "이름이 없는";
Blockly.Msg["VARIABLES_DEFAULT_NAME"] = "항목";
Blockly.Msg["VARIABLES_GET_CREATE_SET"] = "'집합 %1' 생성";
Blockly.Msg["VARIABLES_GET_HELPURL"] = "https://ko.wikipedia.org/wiki/%EB%B3%80%EC%88%98_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)";
Blockly.Msg["VARIABLES_GET_TOOLTIP"] = "변수에 저장 되어있는 값을 돌려줍니다.";
Blockly.Msg["VARIABLES_SET"] = "%1를 %2로 설정";
Blockly.Msg["VARIABLES_SET_CREATE_GET"] = "'%1 값 읽기' 블럭 생성";
Blockly.Msg["VARIABLES_SET_HELPURL"] = "https://ko.wikipedia.org/wiki/%EB%B3%80%EC%88%98_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)";
Blockly.Msg["VARIABLES_SET_TOOLTIP"] = "변수의 값을 입력한 값으로 변경해 줍니다.";
Blockly.Msg["VARIABLE_ALREADY_EXISTS"] = "'%1' 변수는 이미 존재합니다.";
Blockly.Msg["VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE"] = "'%1' 변수는 다른 유형에 대해 이미 존재합니다: '%2'.";
Blockly.Msg["WORKSPACE_ARIA_LABEL"] = "Blockly 워크스페이스";
Blockly.Msg["WORKSPACE_COMMENT_DEFAULT_TEXT"] = "말해 보세요...";
Blockly.Msg["CONTROLS_FOREACH_INPUT_DO"] = Blockly.Msg["CONTROLS_REPEAT_INPUT_DO"];
Blockly.Msg["CONTROLS_FOR_INPUT_DO"] = Blockly.Msg["CONTROLS_REPEAT_INPUT_DO"];
Blockly.Msg["CONTROLS_IF_ELSEIF_TITLE_ELSEIF"] = Blockly.Msg["CONTROLS_IF_MSG_ELSEIF"];
Blockly.Msg["CONTROLS_IF_ELSE_TITLE_ELSE"] = Blockly.Msg["CONTROLS_IF_MSG_ELSE"];
Blockly.Msg["CONTROLS_IF_IF_TITLE_IF"] = Blockly.Msg["CONTROLS_IF_MSG_IF"];
Blockly.Msg["CONTROLS_IF_MSG_THEN"] = Blockly.Msg["CONTROLS_REPEAT_INPUT_DO"];
Blockly.Msg["CONTROLS_WHILEUNTIL_INPUT_DO"] = Blockly.Msg["CONTROLS_REPEAT_INPUT_DO"];
Blockly.Msg["LISTS_CREATE_WITH_ITEM_TITLE"] = Blockly.Msg["VARIABLES_DEFAULT_NAME"];
Blockly.Msg["LISTS_GET_INDEX_HELPURL"] = Blockly.Msg["LISTS_INDEX_OF_HELPURL"];
Blockly.Msg["LISTS_GET_INDEX_INPUT_IN_LIST"] = Blockly.Msg["LISTS_INLIST"];
Blockly.Msg["LISTS_GET_SUBLIST_INPUT_IN_LIST"] = Blockly.Msg["LISTS_INLIST"];
Blockly.Msg["LISTS_INDEX_OF_INPUT_IN_LIST"] = Blockly.Msg["LISTS_INLIST"];
Blockly.Msg["LISTS_SET_INDEX_INPUT_IN_LIST"] = Blockly.Msg["LISTS_INLIST"];
Blockly.Msg["MATH_CHANGE_TITLE_ITEM"] = Blockly.Msg["VARIABLES_DEFAULT_NAME"];
Blockly.Msg["PROCEDURES_DEFRETURN_COMMENT"] = Blockly.Msg["PROCEDURES_DEFNORETURN_COMMENT"];
Blockly.Msg["PROCEDURES_DEFRETURN_DO"] = Blockly.Msg["PROCEDURES_DEFNORETURN_DO"];
Blockly.Msg["PROCEDURES_DEFRETURN_PROCEDURE"] = Blockly.Msg["PROCEDURES_DEFNORETURN_PROCEDURE"];
Blockly.Msg["PROCEDURES_DEFRETURN_TITLE"] = Blockly.Msg["PROCEDURES_DEFNORETURN_TITLE"];
Blockly.Msg["TEXT_APPEND_VARIABLE"] = Blockly.Msg["VARIABLES_DEFAULT_NAME"];
Blockly.Msg["TEXT_CREATE_JOIN_ITEM_TITLE_ITEM"] = Blockly.Msg["VARIABLES_DEFAULT_NAME"];

Blockly.Msg["LOGIC_HUE"] = "100";
Blockly.Msg["LOOPS_HUE"] = "140";
Blockly.Msg["MATH_HUE"] = "170";
Blockly.Msg["TEXTS_HUE"] = "190";
Blockly.Msg["LISTS_HUE"] = "210";
Blockly.Msg["DICTS_HUE"] = "230";
Blockly.Msg["NDARRAY_HUE"] = "250";
Blockly.Msg["MODEL_HUE"] = "270";
Blockly.Msg["COLOUR_HUE"] = "20";
Blockly.Msg["VARIABLES_HUE"] = "290";
Blockly.Msg["VARIABLES_DYNAMIC_HUE"] = "300";
Blockly.Msg["PROCEDURES_HUE"] = "310";
Blockly.Msg["PLOT_HUE"] = "335";
Blockly.Msg["FILE_HUE"] = "360";
Blockly.Msg["MLGAME_HUE"] = "20";